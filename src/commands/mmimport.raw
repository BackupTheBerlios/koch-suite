#!<%%PHP%%> <%%PHP_OPTS%%>
<?
  /* Copyright (c) 2001
   *      Michael Lestinsky. All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
   *    notice, this list of conditions and the following disclaimer.
   * 2. Redistributions in binary form must reproduce the above copyright
   *    notice, this list of conditions and the following disclaimer in the
   *    documentation and/or other materials provided with the distribution.
   * 3. All advertising materials mentioning features or use of this software
   *    must display the following acknowledgement:
   *      This product includes software developed by Michael Lestinsky.
   *
   * THIS SOFTWARE IS PROVIDED BY MICHAEL LESTINSKY ``AS IS'' AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED.  IN NO EVENT SHALL MICHAEL LESTINSKY BE LIABLE
   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
   * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
   * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
   * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
   * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
   * SUCH DAMAGE.
   */

  /*
   * $Id: mmimport.raw,v 1.17 2001/07/01 20:50:06 michael Exp $
   * Michael Lestinsky <michael@zaphod.rhein-neckar.de>, Okt. 2000
   * Import mealmaster-formated recipes into the "Koch-Suite".
   *
   * See the bundled file "LICENCE" for the licence of this script.
   */

  require "<%%PHP_LIBS%%>/config.inc";
  require "<%%PHP_LIBS%%>/functions.inc";

  if (!isset($argc)) $argc = $HTTP_SERVER_VARS["argc"];
  if (!isset($argv)) $argv = $HTTP_SERVER_VARS["argv"];

  $opt_test = 0;
  $opt_test_printmm = 0;
  
  $help = <<<EOD
Usage: $argv[0] [-t|--test [-mm]] [-c category,[cat...]]] [-h|--help]

     -t --test     Test the parser.  Do not import the recipe, but rather re­
                   format it into plain ascii.  Output goes to STDOUT.

     -mm           Reformat parser output to Meal-Master format. 
     
     -c cat,...	   Add comma separated categories to the recipe.

     --help        display this help and exit

EOD;
  
  
  /* Open filedescriptors for the STD-channels */
  $stdin  = fopen("php://stdin", "r");
  $stdout = fopen("php://stdout", "w");
  $stderr = fopen("php://stderr", "w");

  /* parse arguments */
  for ($i = 1; $i < $argc; $i++) {
    switch ($argv[$i]) {
	case "-t":
	case "--test":
              $opt_test++;
              break;
	case "-mm":
              $opt_test_printmm++;
              break;
	      
	case "-c":
	      if (++$i < $argc) {
	        $opt_cat = split(",", $argv[$i]);
	      } else {
                fputs($stderr, "$argv[0]: invalid option -- " . preg_replace("/^-*/", "", $argv[$i]) . "\n");
		exit();
	      }
	      break;

        default:
	      fputs($stderr, "$argv[0]: invalid option -- " . preg_replace("/^-*/", "", $argv[$i]) . "\n");
	      
        case "--help":
	case "-h":
	      fputs($stderr, $help);
	      exit();
    }
  }



  /* Create a temporary file, write $stdin to it and close the
   * temporary file. 
   * Why this way instead of using /dev/stdin directly:
   *   fseek doesn't work on /dev/stdin.
   */

  $temp = tempnam("/tmp", "mmimport");

  $temp_fd = fopen($temp, "w");

  while ($line = fgets($stdin, 1024)) {
    fputs ($temp_fd, preg_replace("/\r/", "", $line));
  }
  fclose ($temp_fd);

  /* Reopen the temporary file for reading */

  $fd = fopen($temp, "r");

  /* --- Main --- */

  while ($line = fgets($fd, 1024)) {
    /* Is the line the start of a new recipe? */
    if (eregi("(-{5}|M{5}).*Meal-Master.*", $line)) { 
      /* parse the recipe */
      $rezept =& parse_recipe($fd, RECIPE_MM);
    } else if (eregi("(={10}).*REZKONV.*", $line)) {
      $rezept =& parse_recipe($fd, RECIPE_RK);
    }

    if (isset($rezept)) {
      
      if (sizeof($opt_cat) > 0)
        $rezept["category"] = array_merge($opt_cat, $rezept["category"]) ;
      
      if ($opt_test) {
        /* Parse the recipe, but don't write it to the database.
         * Main purpose: parser-testing
         */
        if ($opt_test_printmm) {
          fputs($stdout, mmexport($rezept));
        } else {
          fputs($stdout, format_recipe($rezept));
          fputs($stdout, "==========\n");
	}
      } else {
        write_db($rezept);
      }
      unset ($rezept);
    }
  }

  /* Close open files */

  fclose($fd);
  unlink($temp);

  /* --- End --- */
?>
