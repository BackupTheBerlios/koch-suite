<?
  /**
   * Output-Functions for Koch-Suite
   *
   * $Id: output.raw,v 1.30 2001/06/27 13:17:11 michael Exp $
   * This file is automatically included when including functins.inc.
   * It contains all functions for output.
   * @package Lib
   * @modulegroup Output
   * @module output
   * @copyrigth Michael Lestinsky <michael@lestinsky.de>
   */


  /**
   * return a String, which contains the plain-text-formatted recipe 
   *
   * @param array
   * @return string
   */
  function format_recipe(&$rezept) {

    global $Lang;

    $str  = pad_left($Lang['Title'], ' ', 11) . ": " . 
               $rezept["title"] . "\n".
            pad_left($Lang['Cat'], ' ', 11) . ": " . 
               implode(", " , $rezept["category"]) . "\n";
    $str .= pad_left($Lang['Yield'], ' ', 11) . ": " . 
               $rezept["yield"] . "\n\n";

    /* Zutaten: */

    foreach ($rezept["zutaten"] as $z) {
      if (!empty($z["title"])) $str .= $z["title"] . "\n";
      foreach ($z["ingredients"] as $j) {
        $quant = nice_quant($j["quant"]);
        $rline = pad_left ($quant , " ", 7) . " " .
                 pad_right(nice_unit($j["unit"])  , " ", 11) . " " .
                 pad_right($j["ingred"], " ", 28) . "\n";
        $str .= $rline;
      }
      $str .= "\n";
    }

    foreach (length_adjust($rezept["anleitung"], 72) as $line) {
      $str .= $line . "\n";
    }

    return $str;
  }


  /**
   * return a string, which contains the html-formatted recipe
   *
   * @param array
   * @return string
   */
  function format_recipe_html (&$rezept) {
    global $Lang;

    $str = "<h2>" . htmlentities($rezept["title"]) . "</h2>\n";
    $str .= "<table border=\"0\">\n";

    $str .= "  <tr><td><b>" . $Lang['Cat'] . "</b>:</td>";
    $str .= "<td width=\"90%\">";
    $str .= htmlentities(implode(" ", $rezept["category"]));
    $str .= "</td></tr>\n";

    $str .= "  <tr><td><b>" . $Lang['Yield'] . "</b>:</td><td>" . $rezept["yield"] . "</td></tr>\n";

    $str .= "  <tr><td colspan=2>\n";

    $str .= "    <table border=\"0\" width=\"100%\">\n";
    foreach ($rezept["zutaten"] as $z) {
      if (empty($z["title"])) {
        $str .= "      <tr><td colspan=3><b>" .
                       htmlentities($Lang["Ingred"]) .
                       "</b></td></tr>\n";
      } else {
        $str .= "      <tr><td colspan=3><b>" .
                       htmlentities($z["title"]) .
                       "</b></td></tr>\n";
      }

      foreach ($z["ingredients"] as $j) {

        $quant = nice_quant($j["quant"]);
        $unit = nice_unit($j["unit"]);
        $ingred = preg_replace("/^(-*|;*) */", "", $j["ingred"]);
        $str .= "      ";
        $str .= "<tr><td align=\"right\">" . $quant . "</td>" .
                    "<td>" . $unit . "</td>" .
                    "<td width=\"90%\">" . htmlentities($ingred) . "</td>" .
                "</tr>\n";
      }

    }
    $str .= "    </table>\n";
    $str .= "  </td></tr>\n";
 
    $str .= "  <tr><td colspan=\"2\">\n";
    $instr = preg_replace("/(\r)?\n(\r)?\n?/", "<br>\n", htmlentities($rezept["anleitung"]));
    foreach (length_adjust($instr, 65) as $line) {
      $line = preg_replace("/&lt;(p|br)&gt;/", "<\\1>", $line);
      $str .= "    " . $line . "\n";
    }
    $str .= "  </td></tr>\n";
    $str .= "</table>\n";

    return $str;
  }


  /**
   * Generate LaTeX-Footer
   *
   * @return string
   */
  function latex_footer () {
    /* write Latex-Footers */
    $str .= "\\end{document}\n";
    return $str;
  }


  /**
   * Print LaTeX Headers
   *
   * @return string
   */
  function latex_header () {
    /* write the Latex-headers... */
    $str  = "\\documentclass[a4paper,10pt]{article}\n\n";
    $str .= "\\usepackage{german}\n";
    $str .= "\\usepackage[latin1]{inputenc}\n";
    $str .= "\\usepackage{here}\n";
    $str .= "\\usepackage{array}\n";
    $str .= "\\usepackage[lflt]{floatflt}\n";

    $str .= "\\setlength{\\textwidth}{16cm}\n";
    $str .= "\\setlength{\\textheight}{25cm}\n";
    $str .= "\\addtolength{\\topmargin}{-2cm}\n";
    $str .= "\\addtolength{\\oddsidemargin}{-2cm}\n";
    $str .= "\\pagestyle{empty}\n";
    $str .= "\\begin{document}\n";
    $str .= "\\setlength{\\parindent}{0pt}\n";
    $str .= "\\setlength{\\parskip}{1ex plus 0pt minus 0pt}\n";

    return $str;
  }


  /**
   * Convert characters to LaTeX entities
   *
   * Translate all those "special" characters in the input
   * into proper Latex-substitutes.
   * @param string
   * @return string
   */
  function ltx_string ($str) {

    /* Replace some characters with special meanings in latex. */
    $str = strtr($str, array(
                               "_"  => "\\_ ",
                               "&"  => "\\& ",
                               "%"  => "\\% ",
                               "#"  => "\\# ",
                               "{"  => "\\{ ",
                               "}"  => "\\} ",
                               "$"  => "\\$ ", 
                               "\"" => "\\dq ", 
                               "^"  => "\\textasciicircum ",
                               "|"  => "\\textbar ",
                               "~"  => "\\textasciitilde "
                            )
                );

    return $str;
  }


  function latex_export (&$rezept) {
    /* Export a recipe in LaTeX-format */
    global $Lang;

    $c = 0;

    $str .= "\\section*{\\textsf{" . ltx_string($rezept["title"]) . "}}\n";

    /* ... the content... */

    $str .= "\\begin{table}[H]\n";
    $str .= "\\begin{tabular}{rl}\n";
    $str .= "\\textbf{" . $Lang['Yield'] . ":} & " . ltx_string($rezept["yield"]) . "\\\\\n";
    $str .= "\\textbf{" . $Lang['Cat'] . ":} & ";
    foreach ($rezept["category"] as $cat) {
      $str .= ltx_string($cat) . " ";
    }
    $str .= "\\\\\n";
    $str .= "\\end{tabular}\\\\\n";
    $str .= "\\end{table}\n";

    /* ... ingredients, ... */
    $str .= "\\begin{floatingtable}{\n";
    $str .= "\\begin{tabular}{rl|l}\n";
    foreach($rezept["zutaten"] as $z) {
      $str .= "\\hline\n";
      $str .= "\\multicolumn{3}{l}{\\textbf{" . 
              preg_replace("/:/", "", ltx_string($z["title"])) . "}}\\\\\n";
      $str .= "\\hline\n";

      foreach ($z["ingredients"] as $i) {
        $ingred = preg_replace("/^(-*|;*) */", "", $i["ingred"]);
        $c = 0;
        $ingred = length_adjust($ingred, 28);
        while ($line = $ingred[$c]) {
          if ($c == 0) { 
            $ingred_ = ltx_string($line) . "\\\\\n"; 
          } else {
            $ingred_ .= " & & \\hspace{4mm} " . ltx_string($line) . "\\\\\n";
          }
          $c++;
        }
        $str .= nice_quant($i["quant"]) . " & " . 
                nice_unit($i["unit"]) . " & " . 
                $ingred_;
      }
    }
    $str .= "\\hline\n";
    $str .= "\\end{tabular}}\n";
    $str .= "\\end{floatingtable}\n";

    foreach (length_adjust($rezept["anleitung"], 74) as $line) {
      $line = stripslashes($line);
      $line = ltx_string($line);
      $line = preg_replace ('/^:/', "\n:", $line);
      $str .= $line . "\n";
    }
    $str .= "\\newpage\n";
    return $str;
  }


  /**
   * Adjust the String-Length. 
   * return an array containing all individual lines. 
   * @param string $str String
   * @param int    $len Max Length
   * @return array
   */
  function length_adjust ($str, $len) {

    $bar = array();
    $foo = "";

    /* Split up into single words: */
    $a = explode(" ", $str);
    $i = 0;

    /* For each word: */
    while (isset($a[$i])) {

      /* Is it a linebreak? They have a stringlength of 0 */
      if (preg_match("/<(p|br)>/", $a[$i])) {
        $wordlen = 0;
      } else {
        /* String-Length + prefixed Space-character! */
        $wordlen = strlen($a[$i]) + 1;
      }

      if ((strlen($foo) + $wordlen) <= $len) {
        if (preg_match("/<(br|p)>/", $a[$i], $bla)) {
          /* If we have some linebreak: */
          $i++;
          array_push($bar, $foo);
          if ($bla[1] == 'p') {
            array_push($bar, "");
          }
          $foo = "";

        } elseif ($a[$i] == ' ') {
          /* Just skip 'words' if they are 'space-character' */
          $i++; 

        } else {
          /* Apend an whitespace and the word to the current line. */
          $foo .= ((strlen($foo) == 0) ? "" : " ") . $a[$i];
          $i++;
        }
      } else if ($wordlen >= $len) {
        /* Oops, by some accident we have a word here, 
         * which itself is longer then the allowed line-lenght.
         */
        array_push($bar, $foo);
        $foo = $a[$i];
        $i++;
      } else {
        /* Max linelength reached. */
        array_push($bar, $foo);
        $foo = "";
      }
    }

    if ($foo != "") {
      /* include the last line, too */
      array_push($bar, $foo);
    }

    return $bar;
  }


  function mmexport (&$rezept, $strict = true) {
    /* return a Meal-Master-formatted string. */
    global $tool;
    $i = 0;
    $header = "MMMMM-----Koch-Suite (" . KOCHSUITE_VER . ") Export nach Meal-Master-----\n";
    $footer = "MMMMM";

    $str  = "$header\n";
    $str .= "     Title: " . $rezept["title"] . "\n"; 

    $cat_a = $rezept["category"];
    $str .= "Categories: "; 
    while (isset($cat_a[$i])) {
      if ($i != 0) {
        $str  .= ", ";
      }
      $str .= $cat_a[$i];
      $i++;
    }
    $str .= "\n";

    $str .= "     Yield: " . $rezept["yield"] . "\n"; 

    $str .= print_ingred($rezept["zutaten"], $strict) . "\n";
    $a = length_adjust($rezept["anleitung"], 72); 
    foreach ($a as $line) {
      $str .= stripslashes($line) . "\n";
    }
    $str .= "\n$footer\n";

    return $str;
  }


  function mmrezept_header ($str) {
    /* return a valid Mealmaster-subheader */
    $fill = pad_left("", "-", 23 - strlen($str)/2);
    $fill_l = "MMMMM" . $fill;
    $fill_r = $fill . "-----";
    $str = $fill_l . $str . $fill_r;
    return "$str";
  }


  function nice_quant ($quant) {
    /* Return a beautified $qunat-string */

    if (($quant = round($quant, 3)) == 0) {
      $quant = "";              // suppress "0" values.
    }

    return $quant;
  }


  function nice_unit ($unit) {
    /* Lookup a beautified name for a unit */
    if ($GLOBALS["DB_STYLE"] == DB_MYSQL) {
      $req = "select text from EINHEITEN where STRCMP(ABBREV, '$unit') = 0";
    } else {
      $req = "select text from EINHEITEN where ABBREV = '$unit'";
    }
    $result = DB_query($req);

    $r = $result->fetchRow();
    $result->free();

    return $r["text"];
  }


  function pad_left($str, $pad, $length) {
    /* Pad a String from the left side with $pad to a length of $length
     * or if to long: cut it from the rigth to a length of $lenght.
     */
    if (strlen($str) > $length) {
      // snip
    } else {
      while (strlen($str) < $length) {
        $str = $pad . $str;
      }
    }
    return $str;
  }


  function pad_right($str, $pad, $length) {
    /* Pad a String from the rigth side with $pad to a length of $length
     * or if to long: cut it from the rigth to a length of $lenght.
     */
    if (strlen($str) > $length) {
      // snip
    } else {
      while (strlen($str) < $length) {
        $str .= $pad;
      }
    }
    return $str;
  }


  function print_ingred ($r, $strict = true) {
    $i = 0;
    foreach ($r as $z) {
      /* Print a mealmaster-Subheader for subrecipes: */
      if ($z["title"] != "Zutaten:" and $z["title"] != "") {
        $str .= "\n" . mmrezept_header($z["title"]) . "\n";
      } else {
        $str .= "\n";
      }
      /* Print each ingredient on one line: */
      foreach ($z["ingredients"] as $j) {
        $u = 0;

        $quant = nice_quant($j["quant"]);

        if ($strict == true) {
           $a = length_adjust($j["ingred"], 28);
        } else {
           $a = length_adjust($j["ingred"], 65);
        }
    
        $rline = pad_left($quant," ", 7) . " " .
                 pad_right($j["unit"]  , " ", 2) . " " .
                 $a[$u++] . "\n";
        $str .= $rline;
        while (isset($a[$u])) {
          $str .= "           -- " . $a[$u++] . "\n";
        }
      }
      # $str .= "\n";
    }
    return $str;
  }

?>
