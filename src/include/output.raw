<?
  /*
   * Output-Functions for Koch-Suite
   * $Id: output.raw,v 1.22 2001/05/22 00:13:54 michael Exp $
   * This file is automatically included when including functins.inc.
   * It contains all functions for output.
   */


  function format_recipe($rezept) {
    /* return a String, which contains the plain-text-formatted recipe */

    $str  = "     Titel: " . $rezept["title"] . "\n".
            "Kategorien: " . implode(", " , $rezept["category"]) . "\n";

    $str .= " Portionen: " . $rezept["yield"] . "\n\n";

    /* Zutaten: */

    foreach ($rezept["zutaten"] as $z) {
      $str .= $z["title"] . "\n";
      foreach ($z["ingredients"] as $j) {
        $quant = nice_quant($j["quant"]);
        $rline = pad_left ($quant , " ", 7) . " " .
                 pad_right(nice_unit($j["unit"])  , " ", 11) . " " .
                 pad_right($j["ingred"], " ", 28) . "\n";
        $str .= $rline;
      }
      $str .= "\n";
    }

    foreach (length_adjust($rezept["anleitung"], 72) as $line) {
      $str .= $line . "\n";
    }

    return $str;
  }


  function format_recipe_html ($rezept) {
    /* return a string, which contains the html-formatted recipe */
    global $Lang;

    $str = "<h2>" . htmlentities($rezept["title"]) . "</h2>\n";
    $str .= "<table border=\"0\">\n";

    $str .= "  <tr><td><b>" . $Lang['Cat'] . "</b>:</td>";
    $str .= "<td width=\"90%\">";
    $str .= htmlentities(implode(" ", $rezept["category"]));
    $str .= "</td></tr>\n";

    $str .= "  <tr><td><b>" . $Lang['Yield'] . "</b>:</td><td>" . $rezept["yield"] . "</td></tr>\n";

    $str .= "  <tr><td colspan=2>\n";

    $str .= "    <table border=\"0\" width=\"100%\">\n";
    foreach ($rezept["zutaten"] as $z) {
      if (empty($z["title"])) {
        $str .= "      <tr><td colspan=3><b>" .
                       htmlentities($Lang["Ingred"]) .
                       "</b></td></tr>\n";
      } else {
        $str .= "      <tr><td colspan=3><b>" .
                       htmlentities($z["title"]) .
                       "</b></td></tr>\n";
      }

      foreach ($z["ingredients"] as $j) {

        $quant = nice_quant($j["quant"]);
        $unit = nice_unit($j["unit"]);
        $ingred = preg_replace("/^(-*|;*) */", "", $j["ingred"]);
        $str .= "      ";
        $str .= "<tr><td align=\"right\">" . $quant . "</td>" .
                    "<td>" . $unit . "</td>" .
                    "<td width=\"90%\">" . htmlentities($ingred) . "</td>" .
                "</tr>\n";
      }

    }
    $str .= "    </table>\n";
    $str .= "  </td></tr>\n";
 
    $str .= "  <tr><td colspan=\"2\">\n";
    $instr = preg_replace("/(\r)?\n(\r)?\n?/", "<br>\n", htmlentities($rezept["anleitung"]));
    foreach (length_adjust($instr, 65) as $line) {
      $line = preg_replace("/&lt;(p|br)&gt;/", "<\\1>", $line);
      $str .= "    " . $line . "\n";
    }
    $str .= "  </td></tr>\n";
    $str .= "</table>\n";

    return $str;
  }


  function latex_footer () {
    /* write Latex-Footers */
    $str .= "\\end{document}\n";
    return $str;
  }


  function latex_header () {
    /* write the Latex-headers... */
    $str  = "\\documentclass[a4paper,10pt]{article}\n\n";
    $str .= "\\usepackage{german}\n";
    $str .= "\\usepackage[latin1]{inputenc}\n";
    $str .= "\\usepackage{here}\n";
    $str .= "\\usepackage{array}\n";
    $str .= "\\usepackage[lflt]{floatflt}\n";

    $str .= "\\setlength{\\textwidth}{16cm}\n";
    $str .= "\\setlength{\\textheight}{25cm}\n";
    $str .= "\\addtolength{\\topmargin}{-2cm}\n";
    $str .= "\\addtolength{\\oddsidemargin}{-2cm}\n";
    $str .= "\\pagestyle{empty}\n";
    $str .= "\\begin{document}\n";
    $str .= "\\setlength{\\parindent}{0pt}\n";
    $str .= "\\setlength{\\parskip}{1ex plus 0pt minus 0pt}\n";

    return $str;
  }


  function ltx_string ($str) {
    /* Translate all those "special" characters in the input
     * into proper Latex-substitutes.
     */

    #$str = preg_replace("/\\\/", "\\textbackslash ", $str);
    $str = preg_replace("/[\"]/", "\\dq ", $str);
    $str = preg_replace("/([_\&%#\{\}\$])/", "\\\\1", $str);
    $str = preg_replace("/\^/", "\\textasciicircum ", $str);
    $str = preg_replace("/~/", "\\textasciitilde ", $str);
    $str = preg_replace("/\|/", "\\textbar ", $str);

    return $str;
  }


  function latex_export ($rezept) {
    /* Export a recipe in LaTeX-format */

    $c = 0;

    $str .= "\\section*{\\textsf{" . ltx_string($rezept["title"]) . "}}\n";

    /* ... the content... */

    $str .= "\\begin{table}[H]\n";
    $str .= "\\begin{tabular}{rl}\n";
    $str .= "\\textbf{Portionen:} & " . ltx_string($rezept["yield"]) . "\\\\\n";
    $str .= "\\textbf{Kategorie:} & ";
    foreach ($rezept["category"] as $cat) {
      $str .= ltx_string($cat) . " ";
    }
    $str .= "\\\\\n";
    $str .= "\\end{tabular}\\\\\n";
    $str .= "\\end{table}\n";

    /* ... ingredients, ... */
    $str .= "\\begin{floatingtable}{\n";
    $str .= "\\begin{tabular}{rl|l}\n";
    foreach($rezept["zutaten"] as $z) {
      $str .= "\\hline\n";
      $str .= "\\multicolumn{3}{l}{\\textbf{" . 
              preg_replace("/:/", "", ltx_string($z["title"])) . "}}\\\\\n";
      $str .= "\\hline\n";

      foreach ($z["ingredients"] as $i) {
        $ingred = preg_replace("/^(-*|;*) */", "", $i["ingred"]);
        $c = 0;
        $ingred = length_adjust($ingred, 28);
        while ($line = $ingred[$c]) {
          if ($c == 0) { 
            $ingred_ = ltx_string($line) . "\\\\\n"; 
          } else {
            $ingred_ .= " & & \\hspace{4mm} " . ltx_string($line) . "\\\\\n";
          }
          $c++;
        }
        $str .= nice_quant($i["quant"]) . " & " . 
                nice_unit($i["unit"]) . " & " . 
                $ingred_;
      }
    }
    $str .= "\\hline\n";
    $str .= "\\end{tabular}}\n";
    $str .= "\\end{floatingtable}\n";

    foreach (length_adjust($rezept["anleitung"], 74) as $line) {
      $line = stripslashes($line);
      $line = ltx_string($line);
      $line = preg_replace ('/^:/', "\n:", $line);
      $str .= $line . "\n";
    }
    $str .= "\\newpage\n";
    return $str;
  }


  function length_adjust ($str, $len) {
    /* Adjust the String-Length. 
     * return an array containing all individual lines. 
     */

    $bar = array();
    $foo = "";

    if (strlen($str) > $len) {

      /* This is for historical reasons. Before 0.2 all instructions were
       * added with all Newlines included. Since 0.2 they get stripped
       * away and replaced by <p> and <br>. 
       * >>>>> Historical
       */
      $str = preg_replace("/\n:/", "\n <br> :", $str);
      $str = preg_replace("/\n\n/", " <p> ", $str);
      $str = preg_replace("/\n/", " ", $str);
      /* <<<<< Historical */

      /* Ingredient-line to long */
      $a = explode(" ", $str);
      $i = 0;
      while (isset($a[$i])) {
        if (preg_match("/<(p|br)>/", $a[$i])) {
          $wordlen = 0;
        } else {
          $wordlen = strlen($a[$i]) + 1;
          /* String-Length + prefixed Space-character! */
        }
        if ((strlen($foo) + $wordlen) <= $len) {
          if (preg_match("/<(br|p)>/", $a[$i], $bla)) {
            /* If we have some linebreak: */
            $i++;
            array_push($bar, $foo);
            if ($bla[1] == 'p') {
              array_push($bar, "");
            }
            $foo = "";

          } elseif ($a[$i] == ' ') {
            /* Just skip 'words' if they are 'space-character' */
            $i++; 

          } else {
            /* Apend an whitespace and the word to the current line. */
            $foo .= ((strlen($foo) == 0) ? "" : " ") . $a[$i];
            $i++;
          }
        } else if ($wordlen >= $len) {
          /* Oops, by some accident we have a word here, 
           * which itself is longer then the allowed line-lenght.
           */
          array_push($bar, $foo);
          $foo = $a[$i];
          $i++;
        } else {
          array_push($bar, $foo);
          $foo = "";
        }
      }
      if ($foo != "") {
        array_push($bar, $foo);
      }
    } else {
      /* ingredient-line ok */
      array_push($bar, $str);
    }
    return $bar;
  }


  function mmexport ($rezept) {
    /* return a Meal-Master-formatted string. */
    global $kochsuite_ver, $tool;
    $i = 0;
    $header = "MMMMM-----Koch-Suite ($kochsuite_ver) Export nach Meal-Master-----\n";
    $footer = "MMMMM";

    $str  = "$header\n";
    $str .= "     Title: " . $rezept["title"] . "\n"; 

    $cat_a = $rezept["category"];
    $str .= "Categories: "; 
    while (isset($cat_a[$i])) {
      if ($i != 0) {
        $str  .= ", ";
      }
      $str .= $cat_a[$i];
      $i++;
    }
    $str .= "\n";

    $str .= "     Yield: " . $rezept["yield"] . "\n"; 

    $str .= print_ingred($rezept["zutaten"]) . "\n";
    $a = length_adjust($rezept["anleitung"], 72); 
    foreach ($a as $line) {
      $str .= stripslashes($line) . "\n";
    }
    $str .= "\n$footer\n";

    return $str;
  }


  function mmrezept_header ($str) {
    /* return a valid Mealmaster-subheader */
    $fill = pad_left("", "-", 23 - strlen($str)/2);
    $fill_l = "MMMMM" . $fill;
    $fill_r = $fill . "-----";
    $str = $fill_l . $str . $fill_r;
    return "$str";
  }


  function nice_quant ($quant) {
    /* Return a beautified $qunat-string */

    if (($quant = round($quant, 3)) == 0) {
      $quant = "";              // suppress "0" values.
    }

    return $quant;
  }


  function nice_unit ($unit) {
    /* Lookup a beautified name for a unit */
    $req = "select * from EINHEITEN where ABBREV = '$unit'";
    $result = mysql_db_query($GLOBALS["DB_NAME"], $req);

    $r = mysql_fetch_array($result);

    return $r["TEXT"];
  }


  function pad_left($str, $pad, $length) {
    /* Pad a String from the left side with $pad to a length of $length
     * or if to long: cut it from the rigth to a length of $lenght.
     */
    if (strlen($str) > $length) {
      // snip
    } else {
      while (strlen($str) < $length) {
        $str = $pad . $str;
      }
    }
    return $str;
  }


  function pad_right($str, $pad, $length) {
    /* Pad a String from the rigth side with $pad to a length of $length
     * or if to long: cut it from the rigth to a length of $lenght.
     */
    if (strlen($str) > $length) {
      // snip
    } else {
      while (strlen($str) < $length) {
        $str .= $pad;
      }
    }
    return $str;
  }


  function print_ingred ($r) {
    $i = 0;
    foreach ($r as $z) {
      /* Print a mealmaster-Subheader for subrecipes: */
      if ($z["title"] != "Zutaten:") {
        $str .= "\n" . mmrezept_header($z["title"]) . "\n";
      } else {
        $str .= "\n";
      }
      /* Print each ingredient on one line: */
      foreach ($z["ingredients"] as $j) {
        $u = 0;

        $quant = nice_quant($j["quant"]);

        $a = length_adjust($j["ingred"], 28);
        $rline = pad_left($quant," ", 7) . " " .
                 pad_right($j["unit"]  , " ", 2) . " " .
                 $a[$u++] . "\n";
        $str .= $rline;
        while (isset($a[$u])) {
          $str .= "           -- " . $a[$u++] . "\n";
        }
      }
      # $str .= "\n";
    }
    return $str;
  }

?>
